local s={
["Drawing"]=[[
local round = function(num, idp)
	local mult = 10^(idp or 0)
	return math.floor(num * mult + 0.5) / mult
end

local _w, _h = term.getSize()
local copyBuffer = nil

Screen = {
	Width = _w,
	Height = _h
}

Constraints = {
	
}

CurrentConstraint = {1,1,_w,_h}
IgnoreConstraint = false

function AddConstraint(x, y, width, height)
	local x2 = x + width - 1
	local y2 = y + height - 1
	table.insert(Drawing.Constraints, {x, y, x2, y2})
	Drawing.GetConstraint()
end

function RemoveConstraint()
	--table.remove(Drawing.Constraints, #Drawing.Constraints)
	Drawing.Constraints[#Drawing.Constraints] = nil
	Drawing.GetConstraint()
end

function GetConstraint()
	local x = 1
	local y = 1
	local x2 = Drawing.Screen.Width
	local y2 = Drawing.Screen.Height
	for i, c in ipairs(Drawing.Constraints) do
		if x < c[1] then
			x = c[1]
		end
		if y < c[2] then
			y = c[2]
		end
		if x2 > c[3] then
			x2 = c[3]
		end
		if y2 > c[4] then
			y2 = c[4]
		end
	end
	Drawing.CurrentConstraint = {x, y, x2, y2}
end

function WithinContraint(x, y)
	return Drawing.IgnoreConstraint or
		  (x >= Drawing.CurrentConstraint[1] and
		   y >= Drawing.CurrentConstraint[2] and
		   x <= Drawing.CurrentConstraint[3] and
		   y <= Drawing.CurrentConstraint[4])
end

colours.transparent = -1
colors.transparent = -1

DrawCharacters = function (x, y, characters, textColour, bgColour)
	Drawing.WriteStringToBuffer(x, y, characters, textColour, bgColour)
end

DrawBlankArea = function (x, y, w, h, colour)
	if colour ~= colours.transparent then
		Drawing.DrawArea (x, y, w, h, " ", 1, colour)
	end
end

DrawArea = function (x, y, w, h, character, textColour, bgColour)
	--width must be greater than 1, otherwise we get problems
	if w < 0 then
		w = w * -1
	elseif w == 0 then
		w = 1
	end

	for ix = 1, w do
		local currX = x + ix - 1
		for iy = 1, h do
			local currY = y + iy - 1
			Drawing.WriteToBuffer(currX, currY, character, textColour, bgColour)
		end
	end
end

DrawImage = function(_x,_y,tImage, w, h)
	if tImage then
		for y = 1, h do
			if not tImage[y] then
				break
			end
			for x = 1, w do
				if not tImage[y][x] then
					break
				end
				local bgColour = tImage[y][x]
	            local textColour = tImage.textcol[y][x] or colours.white
	            local char = tImage.text[y][x]
	            Drawing.WriteToBuffer(x+_x-1, y+_y-1, char, textColour, bgColour)
			end
		end
	elseif w and h then
		Drawing.DrawBlankArea(_x, _y, w, h, colours.lightGrey)
	end
end

--using .nft
LoadImage = function(path, global)
	local image = {
		text = {},
		textcol = {}
	}
	if fs.exists(path) then
		local _io = io
		if OneOS and global then
			_io = OneOS.IO
		end
        local file = _io.open(path, "r")
        if not file then
        	error('Error Occured. _io:'..tostring(_io)..' OneOS: '..tostring(OneOS)..' OneOS.IO'..tostring(OneOS.IO)..' io: '..tostring(io))
        end
        local sLine = file:read()
        local num = 1
        while sLine do  
            table.insert(image, num, {})
            table.insert(image.text, num, {})
            table.insert(image.textcol, num, {})
                                        
            --As we're no longer 1-1, we keep track of what index to write to
            local writeIndex = 1
            --Tells us if we've hit a 30 or 31 (BG and FG respectively)- next char specifies the curr colour
            local bgNext, fgNext = false, false
            --The current background and foreground colours
            local currBG, currFG = nil,nil
            for i=1,#sLine do
                    local nextChar = string.sub(sLine, i, i)
                    if nextChar:byte() == 30 then
                            bgNext = true
                    elseif nextChar:byte() == 31 then
                            fgNext = true
                    elseif bgNext then
                            currBG = Drawing.GetColour(nextChar)
		                    if currBG == nil then
		                    	currBG = colours.transparent
		                    end
                            bgNext = false
                    elseif fgNext then
                            currFG = Drawing.GetColour(nextChar)
		                    if currFG == nil or currFG == colours.transparent then
		                    	currFG = colours.white
		                    end
                            fgNext = false
                    else
                            if nextChar ~= " " and currFG == nil then
                                    currFG = colours.white
                            end
                            image[num][writeIndex] = currBG
                            image.textcol[num][writeIndex] = currFG
                            image.text[num][writeIndex] = nextChar
                            writeIndex = writeIndex + 1
                    end
            end
            num = num+1
            sLine = file:read()
        end
        file:close()
    else
    	return nil
	end
 	return image
end

DrawCharactersCenter = function(x, y, w, h, characters, textColour,bgColour)
	w = w or Drawing.Screen.Width
	h = h or Drawing.Screen.Height
	x = x or 0
	y = y or 0
	x = math.floor((w - #characters) / 2) + x
	y = math.floor(h / 2) + y

	Drawing.DrawCharacters(x, y, characters, textColour, bgColour)
end

GetColour = function(hex)
	if hex == ' ' then
		return colours.transparent
	end
    local value = tonumber(hex, 16)
    if not value then return nil end
    value = math.pow(2,value)
    return value
end

Clear = function (_colour)
	_colour = _colour or colours.black
	Drawing.DrawBlankArea(1, 1, Drawing.Screen.Width, Drawing.Screen.Height, _colour)
end

Buffer = {}
BackBuffer = {}

TryRestore = false


--TODO: make this quicker
-- maybe sort the pixels in order of colour so it doesn't have to set the colour each time
DrawBuffer = function()
	if TryRestore and Restore then
		Restore()
	end

	for y,row in pairs(Drawing.Buffer) do
		for x,pixel in pairs(row) do
			local shouldDraw = true
			local hasBackBuffer = true
			if Drawing.BackBuffer[y] == nil or Drawing.BackBuffer[y][x] == nil or #Drawing.BackBuffer[y][x] ~= 3 then
				hasBackBuffer = false
			end
			if hasBackBuffer and Drawing.BackBuffer[y][x][1] == Drawing.Buffer[y][x][1] and Drawing.BackBuffer[y][x][2] == Drawing.Buffer[y][x][2] and Drawing.BackBuffer[y][x][3] == Drawing.Buffer[y][x][3] then
				shouldDraw = false
			end
			if shouldDraw then
				term.setBackgroundColour(pixel[3])
				term.setTextColour(pixel[2])
				term.setCursorPos(x, y)
				term.write(pixel[1])
			end
		end
	end
	Drawing.BackBuffer = Drawing.Buffer
	Drawing.Buffer = {}
end

ClearBuffer = function()
	Drawing.Buffer = {}
end

WriteStringToBuffer = function (x, y, characters, textColour,bgColour)
	for i = 1, #characters do
		local character = characters:sub(i,i)
		Drawing.WriteToBuffer(x + i - 1, y, character, textColour, bgColour)
	end
end

WriteToBuffer = function(x, y, character, textColour,bgColour, cached)
	if not cached and not Drawing.WithinContraint(x, y) then
		return
	end
	x = round(x)
	y = round(y)

	if textColour == colours.transparent then
		character = ' '
	end

	if bgColour == colours.transparent then
		Drawing.Buffer[y] = Drawing.Buffer[y] or {}
		Drawing.Buffer[y][x] = Drawing.Buffer[y][x] or {"", colours.white, colours.black}
		Drawing.Buffer[y][x][1] = character
		Drawing.Buffer[y][x][2] = textColour
	else
		Drawing.Buffer[y] = Drawing.Buffer[y] or {}
		Drawing.Buffer[y][x] = {character, textColour, bgColour}
	end

	if copyBuffer then
		copyBuffer[y] = copyBuffer[y] or {}
		copyBuffer[y][x] = {character, textColour, bgColour}		
	end
end

DrawCachedBuffer = function(buffer)
	for y, row in pairs(buffer) do
		for x, pixel in pairs(row) do
			WriteToBuffer(x, y, pixel[1], pixel[2], pixel[3], true)
		end
	end
end

StartCopyBuffer = function()
	copyBuffer = {}
end

EndCopyBuffer = function()
	local tmpCopy = copyBuffer
	copyBuffer = nil
	return tmpCopy
end
]],
["Helpers"]=[[
LongestString = function(input, key, isKey)
	local length = 0
	if isKey then
		for k, v in pairs(input) do
			local titleLength = string.len(k)
			if titleLength > length then
				length = titleLength
			end
		end
	else
		for i = 1, #input do
			local value = input[i]
			if key then
				if value[key] then
					value = value[key]
				else
					value = ''
				end
			end
			local titleLength = string.len(value)
			if titleLength > length then
				length = titleLength
			end
		end
	end
	return length
end

Split = function(str,sep)
    sep=sep or'/'
    return str:match("(.*"..sep..")")
end

Extension = function(path, addDot)
	if not path then
		return nil
	elseif not string.find(fs.getName(path), '%.') then
		if not addDot then
			return fs.getName(path)
		else
			return ''
		end
	else
		local _path = path
		if path:sub(#path) == '/' then
			_path = path:sub(1,#path-1)
		end
		local extension = _path:gmatch('%.[0-9a-z]+$')()
		if extension then
			extension = extension:sub(2)
		else
			--extension = nil
			return ''
		end
		if addDot then
			extension = '.'..extension
		end
		return extension:lower()
	end
end

RemoveExtension = function(path)
--local name = string.match(fs.getName(path), '(%a+)%.?.-')
	if path:sub(1,1) == '.' then
		return path
	end
	local extension = Helpers.Extension(path)
	if extension == path then
		return fs.getName(path)
	end
	return string.gsub(path, extension, ''):sub(1, -2)
end

RemoveFileName = function(path)
	if string.sub(path, -1) == '/' then
		path = string.sub(path, 1, -2)
	end
	local v = string.match(path, "(.-)([^\\/]-%.?([^%.\\/]*))$")
	if type(v) == 'string' then
		return v
	end
	return v[1]
end

TruncateString = function(sString, maxLength)
	if #sString > maxLength then
		sString = sString:sub(1,maxLength-3)
		if sString:sub(-1) == ' ' then
			sString = sString:sub(1,maxLength-4)
		end
		sString = sString  .. '...'
	end
	return sString
end

TruncateStringStart = function(sString, maxLength)
	local len = #sString
	if #sString > maxLength then
		sString = sString:sub(len - maxLength, len - 3)
		if sString:sub(-1) == ' ' then
			sString = sString:sub(len - maxLength, len - 4)
		end
		sString = '...' .. sString
	end
	return sString
end

WrapText = function(text, maxWidth)
	local lines = {''}
    for word, space in text:gmatch('(%S+)(%s*)') do
            local temp = lines[#lines] .. word .. space:gsub('\n','')
            if #temp > maxWidth then
                    table.insert(lines, '')
            end
            if space:find('\n') then
                    lines[#lines] = lines[#lines] .. word
                    
                    space = space:gsub('\n', function()
                            table.insert(lines, '')
                            return ''
                    end)
            else
                    lines[#lines] = lines[#lines] .. word .. space
            end
    end
	return lines
end

TidyPath = function(path)
	path = '/'..path
	if fs.exists(path) and fs.isDir(path) then
		path = path .. '/'
	end

	path, n = path:gsub("//", "/")
	while n > 0 do
		path, n = path:gsub("//", "/")
	end
	return path
end

Capitalise = function(str)
	return str:sub(1, 1):upper() .. str:sub(2, -1)
end

Round = function(num, idp)
	local mult = 10^(idp or 0)
	return math.floor(num * mult + 0.5) / mult
end
]],
["Object"]=[[
X = 1
Y = 1
Width = 1
Height = 1
Parent = nil
OnClick = nil
Visible = true
IgnoreClick = false
Name = nil 
ClipDrawing = true
UpdateDrawBlacklist = {}
Fixed = false

DrawCache = {}

NeedsDraw = function(self)
	if not self.Visible then
		return false
	end
	
	if not self.DrawCache.Buffer or self.DrawCache.AlwaysDraw or self.DrawCache.NeedsDraw then
		return true
	end

	if self.OnNeedsUpdate then
		if self.OnNeedsUpdate() then
			return true
		end
	end

	if self.Children then
		for i, v in ipairs(self.Children) do
			if v:NeedsDraw() then
				return true
			end
		end
	end
end

GetPosition = function(self)
	return self.Bedrock:GetAbsolutePosition(self)
end

GetOffsetPosition = function(self)
	if not self.Parent then
		return {X = 1, Y = 1}
	end

	local offset = {X = 0, Y = 0}
	if not self.Fixed and self.Parent.ChildOffset then
		offset = self.Parent.ChildOffset
	end

	return {X = self.X + offset.X, Y = self.Y + offset.Y}
end

Draw = function(self)
	if not self.Visible then
		return
	end

	self.DrawCache.NeedsDraw = false
	local pos = self:GetPosition()
	Drawing.StartCopyBuffer()

	if self.ClipDrawing then
		Drawing.AddConstraint(pos.X, pos.Y, self.Width, self.Height)
	end

	if self.OnDraw then
		self:OnDraw(pos.X, pos.Y)
	end

	self.DrawCache.Buffer = Drawing.EndCopyBuffer()
	
	if self.Children then
		for i, child in ipairs(self.Children) do
			local pos = child:GetOffsetPosition()
			if pos.Y + self.Height > 1 and pos.Y <= self.Height and pos.X + self.Width > 1 and pos.X <= self.Width then
				child:Draw()
			end
		end
	end

	if self.ClipDrawing then
		Drawing.RemoveConstraint()
	end	
end

ForceDraw = function(self, ignoreChildren, ignoreParent, ignoreBedrock)
	if not ignoreBedrock and self.Bedrock then
		self.Bedrock:ForceDraw()
	end
	self.DrawCache.NeedsDraw = true
	if not ignoreParent and self.Parent then
		self.Parent:ForceDraw(true, nil, true)
	end
	if not ignoreChildren and self.Children then
		for i, child in ipairs(self.Children) do
			child:ForceDraw(nil, true, true)
		end
	end
end

OnRemove = function(self)
	if self == self.Bedrock:GetActiveObject() then
		self.Bedrock:SetActiveObject()
	end
end

Initialise = function(self, values)
	local _new = values    -- the new instance
	_new.DrawCache = {
		NeedsDraw = true,
		AlwaysDraw = false,
		Buffer = nil
	}
	setmetatable(_new, {__index = self} )

	local new = {} -- the proxy
	setmetatable(new, {
		__index = _new,

		__newindex = function (t,k,v)
			if v ~= _new[k] then
				_new[k] = v
				if t.OnUpdate then
					t:OnUpdate(k)
				end

				if t.UpdateDrawBlacklist[k] == nil then
					t:ForceDraw()
				end
			end
		end
	})
	if new.OnInitialise then
		new:OnInitialise()
	end

	return new
end

Click = function(self, event, side, x, y)
	if self.Visible and not self.IgnoreClick then
		if event == 'mouse_click' and self.OnClick and self:OnClick(event, side, x, y) ~= false then
			return true
		elseif event == 'mouse_drag' and self.OnDrag and self:OnDrag(event, side, x, y) ~= false then
			return true
		elseif event == 'mouse_scroll' and self.OnScroll and self:OnScroll(event, side, x, y) ~= false then
			return true
		else
			return false
		end
	else
		return false
	end

end

ToggleMenu = function(self, name, x, y)
	return self.Bedrock:ToggleMenu(name, self, x, y)
end

function OnUpdate(self, value)
	if value == 'Z' then
		self.Bedrock:ReorderObjects()
	end
end
]],
}
local a={
["Button"]=[[
BackgroundColour = colours.lightGrey
ActiveBackgroundColour = colours.blue
ActiveTextColour = colours.white
TextColour = colours.black
DisabledTextColour = colours.lightGrey
Text = ""
Toggle = nil
Momentary = true --TODO: the flash doesn't actually appear because it is skipped over in the 0.05s
AutoWidth = true
Align = 'Center'
Enabled = true

OnUpdate = function(self, value)
	if value == 'Text' and self.AutoWidth then
		self.Width = #self.Text + 2
	end
end

OnDraw = function(self, x, y)
	local bg = self.BackgroundColour

	if self.Toggle then
		bg = self.ActiveBackgroundColour
	end

	local txt = self.TextColour
	if self.Toggle then
		txt = self.ActiveTextColour
	end
	if not self.Enabled then
		txt = self.DisabledTextColour
	end
	Drawing.DrawBlankArea(x, y, self.Width, self.Height, bg)

	local _x = 1
    if self.Align == 'Right' then
        _x = self.Width - #self.Text - 1
    elseif self.Align == 'Center' then
        _x = math.floor((self.Width - #self.Text) / 2)
    end
	Drawing.DrawCharacters(x + _x, y, self.Text, txt, bg)
end

OnLoad = function(self)
	if self.Toggle ~= nil then
		self.Momentary = false
	end
end

Click = function(self, event, side, x, y)
	if self.Visible and not self.IgnoreClick and self.Enabled and event ~= 'mouse_scroll' then
		if self.OnClick then
			if self.Momentary then
				self.Toggle = true
				self.Bedrock:StartTimer(function()self.Toggle = false end,0.25)
			elseif self.Toggle ~= nil then
				self.Toggle = not self.Toggle
			end

			self:OnClick(event, side, x, y, self.Toggle)
		else
			self.Toggle = not self.Toggle
		end
		return true
	else
		return false
	end
end
]],
["CollectionView"]=[[
Inherit = 'ScrollView'
UpdateDrawBlacklist = {['NeedsItemUpdate']=true}

TextColour = colours.black
BackgroundColour = colours.white
Items = false
NeedsItemUpdate = false
SpacingX = 2
SpacingY = 1

OnDraw = function(self, x, y)
	if self.NeedsItemUpdate then
		self:UpdateItems()
		self.NeedsItemUpdate = false
	end
	Drawing.DrawBlankArea(x, y, self.Width, self.Height, self.BackgroundColour)
end

local function MaxIcons(self, obj)
	local x, y = 2, 1
	if not obj.Height or not obj.Width then
		error('You must provide each object\'s height when adding to a CollectionView.')
	end
	local slotHeight = obj.Height + self.SpacingY
	local slotWidth = obj.Width + self.SpacingX
	local maxX = math.floor((self.Width - 2) / slotWidth)
	return x, y, maxX, slotWidth, slotHeight
end

local function IconLocation(self, obj, i)
	local x, y, maxX, slotWidth, slotHeight = MaxIcons(self, obj)
	local rowPos = ((i - 1) % maxX)
	local colPos = math.ceil(i / maxX) - 1
	x = x + (slotWidth * rowPos)
	y = y + colPos * slotHeight
	return x, y
end

local function AddItem(self, v, i)
	local toggle = false
	if not self.CanSelect then
		toggle = nil
	end
	local x, y = IconLocation(self, v, i)
	local item = {
		["X"]=x,
		["Y"]=y,
		["Name"]="CollectionViewItem",
		["Type"]="View",
		["TextColour"]=self.TextColour,
		["BackgroundColour"]=-1,
		OnClick = function(itm)
			if self.CanSelect then
				for i2, _v in ipairs(self.Children) do
					_v.Toggle = false
				end
				self.Selected = itm
			end
		end
    }
	for k, _v in pairs(v) do
		item[k] = _v
   	end
	self:AddObject(item)
end


UpdateItems = function(self)
	self:RemoveAllObjects()
	local groupMode = false
	for k, v in pairs(self.Items) do
		if type(k) == 'string' then
			groupMode = true
			break
		end
	end

	for i, v in ipairs(self.Items) do
		AddItem(self, v, i)
	end
	self:UpdateScroll()
end

OnUpdate = function(self, value)
	if value == 'Items' then
		self.NeedsItemUpdate = true
	end
end
]],
["ImageView"]=[[
Image = false

OnDraw = function(self, x, y)
	Drawing.DrawImage(x, y, self.Image, self.Width, self.Height)
end

OnLoad = function(self)
	if self.Path and fs.exists(self.Path) then
		self.Image = Drawing.LoadImage(self.Path)
	end
end

OnUpdate = function(self, value)
	if value == 'Path' then
		if self.Path and fs.exists(self.Path) then
			self.Image = Drawing.LoadImage(self.Path)
		end
	end
end
]],
["Label"]=[[
TextColour = colours.black
BackgroundColour = colours.transparent
Text = ""
AutoWidth = false
Align = 'Left'

local wrapText = function(text, maxWidth)
    local lines = {''}
    for word, space in text:gmatch('(%S+)(%s*)') do
        local temp = lines[#lines] .. word .. space:gsub('\n','')
        if #temp > maxWidth then
            table.insert(lines, '')
        end
        if space:find('\n') then
            lines[#lines] = lines[#lines] .. word
            
            space = space:gsub('\n', function()
                    table.insert(lines, '')
                    return ''
            end)
        else
            lines[#lines] = lines[#lines] .. word .. space
        end
    end
    if #lines[1] == 0 then
        table.remove(lines,1)
    end
    return lines
end

OnUpdate = function(self, value)
    if value == 'Text' then
        if self.AutoWidth then
            self.Width = #self.Text
        else
            self.Height = #wrapText(self.Text, self.Width)
        end
    end
end

OnDraw = function(self, x, y)
	for i, v in ipairs(wrapText(self.Text, self.Width)) do
        local _x = 0
        if self.Align == 'Right' then
            _x = self.Width - #v
        elseif self.Align == 'Center' then
            _x = math.floor((self.Width - #v) / 2)
        end
		Drawing.DrawCharacters(x + _x, y + i - 1, v, self.TextColour, self.BackgroundColour)
	end
end
]],
["ListView"]=[[
Inherit = 'ScrollView'
UpdateDrawBlacklist = {['NeedsItemUpdate']=true}

TextColour = colours.black
BackgroundColour = colours.white
HeadingColour = colours.lightGrey
SelectionBackgroundColour = colours.blue
SelectionTextColour = colours.white
Items = false
CanSelect = false
Selected = nil
NeedsItemUpdate = false
ItemMargin = 1
HeadingMargin = 0
TopMargin = 0

OnDraw = function(self, x, y)
	if self.NeedsItemUpdate then
		self:UpdateItems()
	end
	Drawing.DrawBlankArea(x, y, self.Width, self.Height, self.BackgroundColour)
end

local function AddItem(self, v, x, y, group)
	local toggle = false
	if not self.CanSelect then
		toggle = nil
	elseif v.Selected then
		toggle = true
	end
	local item = {
		["Width"]=self.Width,
		["X"]=x,
		["Y"]=y,
		["Name"]="ListViewItem",
		["Type"]="Button",
		["TextColour"]=self.TextColour,
		["BackgroundColour"]=-1,
		["ActiveTextColour"]=self.SelectionTextColour,
		["ActiveBackgroundColour"]=self.SelectionBackgroundColour,
		["Align"]='Left',
		["Toggle"]=toggle,
		["Group"]=group,
		OnClick = function(itm)
			if self.CanSelect then
				for i2, _v in ipairs(self.Children) do
					_v.Toggle = false
				end
				self.Selected = itm
			end
		end
    }
    if type(v) == 'table' then
    	for k, _v in pairs(v) do
    		item[k] = _v
    	end
    else
		item.Text = v
    end
	
	local itm = self:AddObject(item)
	if v.Selected then
		self.Selected = itm
	end
end

UpdateItems = function(self)
	if not self.Items or type(self.Items) ~= 'table' then
		self.Items = {}
	end
	self.Selected = nil
	self:RemoveAllObjects()
	local groupMode = false
	for k, v in pairs(self.Items) do
		if type(k) == 'string' then
			groupMode = true
			break
		end
	end

	if not groupMode then
		for i, v in ipairs(self.Items) do
			AddItem(self, v, self.ItemMargin, i)
		end
	else
		local y = self.TopMargin
		for k, v in pairs(self.Items) do
			y = y + 1
			AddItem(self, {Text = k, TextColour = self.HeadingColour, IgnoreClick = true}, self.HeadingMargin, y)
			for i, _v in ipairs(v) do
				y = y + 1
				AddItem(self, _v, 1, y, k)
			end
			y = y + 1
		end
	end
	self:UpdateScroll()
	self.NeedsItemUpdate = false
end

OnKeyChar = function(self, event, keychar)
	if keychar == keys.up or keychar == keys.down then
		local n = self:GetIndex(self.Selected)
		if keychar == keys.up then
			n = n - 1
		else
			n = n + 1
		end
		local new = self:GetNth(n)
		if new then
			self:SelectItem(new)
		end
	elseif keychar == keys.enter and self.Selected then
		self.Selected:Click('mouse_click', 1, 1, 1)
	end
end

--returns the index/'n' of the given item
GetIndex = function(self, obj)
	local n = 1
	for i, v in ipairs(self.Children) do
		if not v.IgnoreClick then
			if obj == v then
				return n
			end
			n = n + 1
		end
	end
end

--gets the 'nth' list item (does not include headings)
GetNth = function(self, n)
	local _n = 1
	for i, v in ipairs(self.Children) do
		if not v.IgnoreClick then
			if n == _n then
				return v
			end
			_n = _n + 1
		end
	end
end

SelectItem = function(self, item)
	for i, v in ipairs(self.Children) do
		v.Toggle = false
	end
	self.Selected = item
	item.Toggle = true
end

OnUpdate = function(self, value)
	if value == 'Items' then
		self.NeedsItemUpdate = true
	end
end
]],
["Menu"]=[[
Inherit = 'View'

TextColour = colours.black
BackgroundColour = colours.white
HideTop = false

OnDraw = function(self, x, y)
	Drawing.IgnoreConstraint = true
	Drawing.DrawBlankArea(x + 1, y + (self.HideTop and 0 or 1), self.Width, self.Height + (self.HideTop and 1 or 0), colours.grey)
	Drawing.IgnoreConstraint = false
	Drawing.DrawBlankArea(x, y, self.Width, self.Height, self.BackgroundColour)
end

OnLoad = function(self)
	local owner = self.Owner
	if type(owner) == 'string' then
		owner = self.Bedrock:GetObject(self.Owner)
	end

	if owner then
		if self.X == 0 and self.Y == 0 then
			local pos = owner:GetPosition()
			self.X = pos.X
			self.Y = pos.Y + owner.Height
		end
		self.Owner = owner
	else
		self.Owner = nil
	end
end

OnUpdate = function(self, value)
	if value == 'Children' then
		self.Width = self.Bedrock.Helpers.LongestString(self.Children, 'Text') + 2
		self.Height = #self.Children + 1 + (self.HideTop and 0 or 1)
		if not self.BaseY then
			self.BaseY = self.Y
		end

		for i, v in ipairs(self.Children) do
			if v.TextColour then
				v.TextColour = self.TextColour
			end
			if v.BackgroundColour then
				v.BackgroundColour = colours.transparent
			end
			if v.Colour then
				v.Colour = colours.lightGrey
			end
			v.Align = 'Left'
			v.X = 1
			v.Y = i + (self.HideTop and 0 or 1)
			v.Width = self.Width
			v.Height = 1
		end

		self.Y = self.BaseY
		local pos = self:GetPosition()
		if pos.Y + self.Height + 1 > Drawing.Screen.Height then
			self.Y = self.BaseY - ((self.Height +  pos.Y) - Drawing.Screen.Height)
		end
		
		if pos.X + self.Width > Drawing.Screen.Width then
			self.X = Drawing.Screen.Width - self.Width
		end
	end
end

Close = function(self, isBedrockCall)
	self.Bedrock.Menu = nil
	self.Parent:RemoveObject(self)
	if self.Owner and self.Owner.Toggle then
		self.Owner.Toggle = false
	end
	self.Parent:ForceDraw()
	self = nil
end

OnChildClick = function(self, child, event, side, x, y)
	self:Close()
end
]],
["Overlay"]=[[
Inherit = 'View'

TextColour = colours.black
BackgroundColour = colours.white

OnDraw = function(self, x, y)
	if self.BackgroundColour then
		Drawing.DrawBlankArea(x, y, self.Width, self.Height, self.BackgroundColour)
	end
end

OnLoad = function(self)
	self:GetObject('OneButton').OnClick = function(btn)
		if btn:ToggleMenu('onemenu') then
			--TODO: updating
			self.Bedrock:GetObject('DesktopMenuItem').OnClick = function(itm)
				Current.Desktop:SwitchTo()
			end

			self.Bedrock:GetObject('AboutMenuItem').OnClick = function(itm)
				Helpers.OpenFile('System/Programs/About OneOS.program')
			end

			self.Bedrock:GetObject('SettingsMenuItem').OnClick = function(itm)
				Helpers.OpenFile('System/Programs/Settings.program')
			end

			self.Bedrock:GetObject('RestartMenuItem').OnClick = function(itm)
				Restart()
			end

			self.Bedrock:GetObject('ShutdownMenuItem').OnClick = function(itm)
				Shutdown()
			end
		end
	end

	self:GetObject('SearchButton').OnClick = function(btn, event, side, x, y, toggle)
		if toggle then
			Search.Open()
		end
	end

	self:UpdateButtons()
end

UpdateButtons = function(self)
	if Current.Program then
		if Current.Program.Environment.OneOS.ToolBarColor ~= colours.white then
			self.BackgroundColour = Current.Program.Environment.OneOS.ToolBarColor
		else
			self.BackgroundColour = Current.Program.Environment.OneOS.ToolBarColour
		end
		
		if Current.Program.Environment.OneOS.ToolBarTextColor ~= colours.black then
			self.TextColour = Current.Program.Environment.OneOS.ToolBarTextColor
		else
			self.TextColour = Current.Program.Environment.OneOS.ToolBarTextColour
		end
	else
		self.BackgroundColour = colours.white
		self.TextColour = colours.black
	end

	for i, v in ipairs(self.Children) do
		if v.TextColour then
			v.TextColour = self.TextColour
		end
	end

	--TODO: make this more efficient
	self:RemoveObjects('ProgramButton')

	local x = 6
	for i, program in ipairs(Current.Programs) do
		if program and not program.Hidden then
			local bg = self.BackgroundColour
			local tc = self.TextColour
			local button = ''
			if Current.Program and Current.Program == program then
				bg = colours.lightBlue
				tc = colours.white
				button = 'x '
			end

			local object = self:AddObject({
		      ["Y"]=1,
		      ["X"]=x,
		      ["Name"]="ProgramButton",
		      ["Type"]="Button",
		      ["Text"]=button..program.Title,
		      ["TextColour"]=tc,
		      ["BackgroundColour"]=bg
		    })
		    x = x + object.Width

			object.Program = program

		    object.OnClick = function(obj, event, side, x, y)
		    	if side == 3 then
		    		obj.Program:Close()
		    	elseif button == 'x ' then
		    		if x == 2 then
		    			obj.Program:Close()
		    		end
		    	else
		    		obj.Program:SwitchTo()
		    	end
				self:UpdateButtons()
		   	end
		end
	end
	if not self.Bedrock.IsDrawing then
		self:ForceDraw()
	end
end
]],
["ProgressBar"]=[[
BackgroundColour = colours.lightGrey
BarColour = colours.blue
TextColour = colours.white
ShowText = false
Value = 0
Maximum = 1

OnDraw = function(self, x, y)
	Drawing.DrawBlankArea(x, y, self.Width, self.Height, self.BackgroundColour)

	local values = self.Value
	local barColours = self.BarColour
	if type(values) == 'number' then
		values = {values}
	end
	if type(barColours) == 'number' then
		barColours = {barColours}
	end
	local total = 0
	local _x = x
	for i, v in ipairs(values) do
		local width = self.Bedrock.Helpers.Round((v / self.Maximum) * self.Width)
		total = total + v
		Drawing.DrawBlankArea(_x, y, width, self.Height, barColours[((i-1)%#barColours)+1])
		_x = _x + width
	end

	if self.ShowText then
		local text = self.Bedrock.Helpers.Round((total / self.Maximum) * 100) .. '%'
		Drawing.DrawCharactersCenter(x, y, self.Width, self.Height, text, self.TextColour, colours.transparent)
	end
end
]],
["ScrollBar"]=[[
BackgroundColour = colours.lightGrey
BarColour = colours.lightBlue
Scroll = 0
MaxScroll = 0
ClickPoint = nil
Fixed = true

OnUpdate = function(self, value)
	if value == 'Text' and self.AutoWidth then
		self.Width = #self.Text + 2
	end
end

OnDraw = function(self, x, y)
	local barHeight = self.Height * (self.Height / (self.Height + self.MaxScroll))
    if barHeight < 3 then
      barHeight = 3
    end
    local percentage = (self.Scroll/self.MaxScroll)

    Drawing.DrawBlankArea(x, y, self.Width, self.Height, self.BackgroundColour)
    Drawing.DrawBlankArea(x, y + self.Bedrock.Helpers.Round(self.Height*percentage - barHeight*percentage), self.Width, barHeight, self.BarColour)
end

OnScroll = function(self, event, direction, x, y)
	if event == 'mouse_scroll' then
		direction = self.Bedrock.Helpers.Round(direction * 3)
	end
	if self.Scroll < 0 or self.Scroll > self.MaxScroll then
		return false
	end
	local old = self.Scroll
	self.Scroll = self.Bedrock.Helpers.Round(self.Scroll + direction)
	if self.Scroll < 0 then
		self.Scroll = 0
	elseif self.Scroll > self.MaxScroll then
		self.Scroll = self.MaxScroll
	end

	if self.Scroll ~= old and self.OnChange then
		self:OnChange()
	end
end

OnClick = function(self, event, side, x, y)
	if event == 'mouse_click' then
		self.ClickPoint = y
	else
		local gapHeight = self.Height - (self.Height * (self.Height / (self.Height + self.MaxScroll)))
		local barHeight = self.Height * (self.Height / (self.Height + self.MaxScroll))
		--local delta = (self.Height + self.MaxScroll) * ((y - self.ClickPoint) / barHeight)
		local delta = ((y - self.ClickPoint)/gapHeight)*self.MaxScroll
		--l(((y - self.ClickPoint)/gapHeight))
		--l(delta)
		self.Scroll = delta
		--l(self.Scroll)
		--l('----')
		if self.Scroll < 0 then
			self.Scroll = 0
		elseif self.Scroll > self.MaxScroll then
			self.Scroll = self.MaxScroll
		end
		if self.OnChange then
			self:OnChange()
		end
	end

	local relScroll = self.MaxScroll * ((y-1)/self.Height)
	if y == self.Height then
		relScroll = self.MaxScroll
	end
	self.Scroll = self.Bedrock.Helpers.Round(relScroll)


end

OnDrag = OnClick
]],
["ScrollView"]=[[
Inherit = 'View'
ChildOffset = false
ContentWidth = 0
ContentHeight = 0

CalculateContentSize = function(self)
	local function calculateObject(obj)
		local pos = obj:GetPosition()
		local x2 = pos.X + obj.Width - 1
		local y2 = pos.Y + obj.Height - 1
		if obj.Children then
			for i, child in ipairs(obj.Children) do
				local _x2, _y2 = calculateObject(child)
				if _x2 > x2 then
					x2 = _x2
				end
				if _y2 > y2 then
					y2 = _y2
				end
			end
		end
		return x2, y2
	end

	local pos = self:GetPosition()
	local x2, y2 = calculateObject(self)
	self.ContentWidth = x2 - pos.X + 1
	self.ContentHeight = y2 - pos.Y + 1
end

UpdateScroll = function(self)
	self.ChildOffset.Y = 0
	self:CalculateContentSize()
	if self.ContentHeight > self.Height then
		if not self:GetObject('ScrollViewScrollBar') then
			local _scrollBar = self:AddObject({
				["Name"] = 'ScrollViewScrollBar',
				["Type"] = 'ScrollBar',
				["X"] = self.Width,
				["Y"] = 1,
				["Width"] = 1,
				["Height"] = self.Height,
				["Z"]=999
			})

			_scrollBar.OnChange = function(scrollBar)
				self.ChildOffset.Y = -scrollBar.Scroll
				for i, child in ipairs(self.Children) do
					child:ForceDraw()
				end
			end
		end
		self:GetObject('ScrollViewScrollBar').MaxScroll = self.ContentHeight - self.Height
	else
		self:RemoveObject('ScrollViewScrollBar')
	end
end

OnScroll = function(self, event, direction, x, y)
	if self:GetObject('ScrollViewScrollBar') then
		self:GetObject('ScrollViewScrollBar'):OnScroll(event, direction, x, y)
	end
end

OnLoad = function(self)
	if not self.ChildOffset or not self.ChildOffset.X or not self.ChildOffset.Y then
		self.ChildOffset = {X = 0, Y = 0}
	end
end
]],
["SearchView"]=[[
Inherit = 'View'

BackgroundColour = colours.grey

OnLoad = function(self)
	local searchBox = self:AddObject({
		["X"]=2,
		["Y"]=2,
		["Width"]="100%,-2",
		["Type"]="TextBox",
		["Name"]="SearchTextBox",
		["Placeholder"]="Search...",
	})

	self:AddObject({
		["X"]=1,
		["Y"]=4,
		["Width"]="100%",
		["Height"]="100%,-3",
		["BackgroundColour"]=-1,
		["Type"]="ListView",
		["Name"]="SearchListView",
		["TextColour"]=colours.white,
		["HeadingMargin"]=1,
		["CanSelect"]=true
	})

	searchBox.OnChange = function(box, event, keychar)
		if keychar == keys.up or keychar == keys.down or keychar == keys.enter then
			self:GetObject('SearchListView'):OnKeyChar('key', keychar)
		else
			self:UpdateSearch()
		end
	end
end

local function safePairs( _t )
  local tKeys = {}
  for key in pairs(_t) do
    table.insert(tKeys, key)
  end
  local currentIndex = 0
  return function()
    currentIndex = currentIndex + 1
    local key = tKeys[currentIndex]
    return key, _t[key]
  end
end

function ItemClick(self, event, side, x, y)
	if side == 1 then
		Search.Close()
		Helpers.OpenFile(self.Path)
	elseif self:ToggleMenu('searchmenu', x, y) then
		self.Bedrock:GetObject('OpenMenuItem').OnClick = function()Search.Close() Helpers.OpenFile(self.Path)end
		self.Bedrock:GetObject('ShowInFilesMenuItem').OnClick = function()Search.Close() Helpers.OpenFile('/System/Programs/Files.program', {self.Path, true})end
	end
end

function UpdateSearch(self)
	local searchItems = {
		Folders = {},
		Documents = {},
		Images = {},
		Programs = {},
		['System Files'] = {},
		Other = {}
	}
	local paths = Indexer.Search(self:GetObject('SearchTextBox').Text)
	local foundSelected = false
	local selected = nil
	if self:GetObject('SearchListView').Selected then
		selected = self:GetObject('SearchListView').Selected.Path
	end

	for i, path in ipairs(paths) do
		local extension = self.Bedrock.Helpers.Extension(path):lower()
		if extension ~= 'shortcut' then
			path = self.Bedrock.Helpers.TidyPath(path)
			local fileType = 'Other'
			if extension == 'txt' or extension == 'text' or extension == 'license' or extension == 'md' then
				fileType = 'Documents'
			elseif extension == 'nft' or extension == 'nfp' or extension == 'skch' then
				fileType = 'Images'
			elseif extension == 'program' then
				fileType = 'Programs'
			elseif extension == 'lua' or extension == 'log' or extension == 'settings' or extension == 'version' or extension == 'hash' or extension == 'fingerprint' then
				fileType = 'System Files'
			elseif fs.isDir(path) then
				fileType = 'Folders'
			end
			if path == selected then
				Log.i('found')
				foundSelected = true
			end
			table.insert(searchItems[fileType], {Path = path, Text = self.Bedrock.Helpers.RemoveExtension(fs.getName(path)), Selected = (path == selected), OnClick = ItemClick})
		end
	end

	for k, v in safePairs(searchItems) do
		if #v == 0 then
			searchItems[k] = nil
		end
	end

	self:GetObject('SearchListView').Items = searchItems
	self:GetObject('SearchListView'):UpdateItems()
	if not foundSelected then
		local first = self:GetObject('SearchListView'):GetNth(1)
		Log.i(first)
		if first then
			self:GetObject('SearchListView'):SelectItem(first)
		end
	end
	
	--ListScrollBar.Scroll = 0

	--Draw()
end
]],
["Separator"]=[[
Colour = colours.grey

OnDraw = function(self, x, y)
	local char = "|"
	if self.Width > self.Height then
		char = '-'
	end
	Drawing.DrawArea(x, y, self.Width, self.Height, char, self.Colour, colours.transparent)
end
]],
["TextBox"]=[[
BackgroundColour = colours.lightGrey
TextColour = colours.black
PlaceholderTextColour = colours.grey
Placeholder = ''
AutoWidth = false
Text = ""
CursorPos = nil
Numerical = false

OnDraw = function(self, x, y)
	Drawing.DrawBlankArea(x, y, self.Width, self.Height, self.BackgroundColour)
	if self.CursorPos > #self.Text then
		self.CursorPos = #self.Text
	elseif self.CursorPos < 0 then
		self.CursorPos = 0
	end
	local text = self.Text
	if self.Bedrock:GetActiveObject() == self then
		if #text > (self.Width - 2) then
			text = text:sub(#text-(self.Width - 3))
			self.Bedrock.CursorPos = {x + 1 + self.Width-2, y}
		else
			self.Bedrock.CursorPos = {x + 1 + self.CursorPos, y}
		end
		self.Bedrock.CursorColour = self.TextColour
	end

	if #tostring(text) == 0 then
		Drawing.DrawCharacters(x + 1, y, self.Placeholder, self.PlaceholderTextColour, self.BackgroundColour)
	else
		Drawing.DrawCharacters(x + 1, y, text, self.TextColour, self.BackgroundColour)
	end
end

OnLoad = function(self)
	if not self.CursorPos then
		self.CursorPos = #self.Text
	end
end

OnClick = function(self, event, side, x, y)
	self.Bedrock:SetActiveObject(self)
	self.CursorPos = x - 2
end

OnKeyChar = function(self, event, keychar)
	if event == 'char' then
		if self.Numerical then
			keychar = tostring(tonumber(keychar))
		end
		if keychar == 'nil' then
			return
		end
		self.Text = string.sub(self.Text, 1, self.CursorPos ) .. keychar .. string.sub( self.Text, self.CursorPos + 1 )
		if self.Numerical then
			self.Text = tostring(tonumber(self.Text))
			if self.Text == 'nil' then
				self.Text = '1'
			end
		end
		
		self.CursorPos = self.CursorPos + 1
		if self.OnChange then
			self:OnChange(event, keychar)
		end
		return false
	elseif event == 'key' then
		if keychar == keys.enter then
			if self.OnChange then
				self:OnChange(event, keychar)
			end
		elseif keychar == keys.left then
			--TODO: behaves odly when the text is too long and arrow keys are pushed
			-- Left
			if self.CursorPos > 0 then
				self.CursorPos = self.CursorPos - 1
				if self.OnChange then
					self:OnChange(event, keychar)
				end
			end
			
		elseif keychar == keys.right then
			-- Right				
			if self.CursorPos < string.len(self.Text) then
				self.CursorPos = self.CursorPos + 1
				if self.OnChange then
					self:OnChange(event, keychar)
				end
			end
		
		elseif keychar == keys.backspace then
			-- Backspace
			if self.CursorPos > 0 then
				self.Text = string.sub( self.Text, 1, self.CursorPos - 1 ) .. string.sub( self.Text, self.CursorPos + 1 )
				self.CursorPos = self.CursorPos - 1					
				if self.Numerical then
					self.Text = tostring(tonumber(self.Text))
					if self.Text == 'nil' then
						self.Text = '1'
					end
				end
				if self.OnChange then
					self:OnChange(event, keychar)
				end
			end
		elseif keychar == keys.home then
			-- Home
			self.CursorPos = 0
			if self.OnChange then
				self:OnChange(event, keychar)
			end
		elseif keychar == keys.delete then
			if self.CursorPos < string.len(self.Text) then
				self.Text = string.sub( self.Text, 1, self.CursorPos ) .. string.sub( self.Text, self.CursorPos + 2 )		
				if self.Numerical then
					self.Text = tostring(tonumber(self.Text))
					if self.Text == 'nil' then
						self.Text = '1'
					end
				end
				if self.OnChange then
					self:OnChange(keychar)
				end
			end
		elseif keychar == keys["end"] then
			-- End
			self.CursorPos = string.len(self.Text)
		else
			if self.OnChange then
				self:OnChange(event, keychar)
			end
			return false
		end
	end
end
]],
["View"]=[[
BackgroundColour = colours.transparent
Children = {}

OnDraw = function(self, x, y)
	if self.BackgroundColour then
		Drawing.DrawBlankArea(x, y, self.Width, self.Height, self.BackgroundColour)
	end
end

OnInitialise = function(self)
	self.Children = {}
end

InitialiseFile = function(self, bedrock, file, name)
	local _new = {}
	_new.X = 1
	_new.Y = 1
	_new.Width = Drawing.Screen.Width
	_new.Height = Drawing.Screen.Height
	_new.BackgroundColour = file.BackgroundColour
	_new.Name = name
	_new.Children = {}
	_new.Bedrock = bedrock
	local new = self:Initialise(_new)
	for i, obj in ipairs(file.Children) do
		local view = bedrock:ObjectFromFile(obj, new)
		if not view.Z then
			view.Z = i
		end
		view.Parent = new
		table.insert(new.Children, view)
	end
	return new
end

function CheckClick(self, object, x, y)
	local offset = {X = 0, Y = 0}
	if not object.Fixed and self.ChildOffset then
		offset = self.ChildOffset
	end
	if object.X + offset.X <= x and object.Y + offset.Y <= y and  object.X + offset.X + object.Width > x and object.Y + offset.Y + object.Height > y then
		return true
	end
end

function DoClick(self, object, event, side, x, y)
	if object then
		if self:CheckClick(object, x, y) then
			local offset = {X = 0, Y = 0}
			if not object.Fixed and self.ChildOffset then
				offset = self.ChildOffset
			end
			return object:Click(event, side, x - object.X - offset.X + 1, y - object.Y + 1 - offset.Y)
		end
	end	
end

Click = function(self, event, side, x, y, z)
	if self.Visible and not self.IgnoreClick then
		for i = #self.Children, 1, -1 do --children are ordered from smallest Z to highest, so this is done in reverse
			local child = self.Children[i]
			if self:DoClick(child, event, side, x, y) then
				if self.OnChildClick then
					self:OnChildClick(child, event, side, x, y)
				end
				return true
			end
		end
		if event == 'mouse_click' and self.OnClick and self:OnClick(event, side, x, y) ~= false then
			return true
		elseif event == 'mouse_drag' and self.OnDrag and self:OnDrag(event, side, x, y) ~= false then
			return true
		elseif event == 'mouse_scroll' and self.OnScroll and self:OnScroll(event, side, x, y) ~= false then
			return true
		else
			return false
		end
	else
		return false
	end
end

OnRemove = function(self)
	if self == self.Bedrock:GetActiveObject() then
		self.Bedrock:SetActiveObject()
	end
	for i, child in ipairs(self.Children) do
		child:OnRemove()
	end
end

local function findObjectNamed(view, name, minI)
	local minI = minI or 0
	if view and view.Children then
		for i, child in ipairs(view.Children) do
			if child.Name == name or child == name then
				return child, i, view
			elseif child.Children then
				local found, index, foundView = findObjectNamed(child, name)
				if found and minI <= index then
					return found, index, foundView
				end
			end
		end
	end
end

function AddObject(self, info, extra)
	if type(info) == 'string' then
		local h = fs.open(self.Bedrock.ViewPath..info..'.view', 'r')
		if h then
			info = textutils.unserialize(h.readAll())
			h.close()
		else
			error('Error in opening object: '..info)
		end
	end

	if extra then
		for k, v in pairs(extra) do
			if v then
				info[k] = v
			end
		end
	end

	local view = self.Bedrock:ObjectFromFile(info, self)
	if not view.Z then
		view.Z = #self.Children + 1
	end
	
	table.insert(self.Children, view)
	if self.Bedrock.View then
		self.Bedrock:ReorderObjects()
	end
	self:ForceDraw()
	return view
end

function GetObject(self, name)
	return findObjectNamed(self, name)
end

local function findObjects(view, name)
	local objects = {}
	if view and view.Children then
		for i, child in ipairs(view.Children) do
			if child.Name == name or child == name then
				table.insert(objects, child)
			elseif child.Children then
				local objs = findObjects(child, name)
				if objs then
					for i2, v in ipairs(objs) do
						table.insert(objects, v)
					end
				end
			end
		end
	end
	return objects
end

function GetObjects(self, name)
	return findObjects(self, name)
end

function RemoveObject(self, name)
	local obj, index, view = findObjectNamed(self, name, minI)
	if index then
		view.Children[index]:OnRemove()
		table.remove(view.Children, index)
		if view.OnUpdate then
			view:OnUpdate('Children')
		end
		return true
	end
	return false
end

function RemoveObjects(self, name)
	local i = 1
	while self:RemoveObject(name) and i < 100 do
		i = i + 1
	end
	
end

function RemoveAllObjects(self)
	for i, child in ipairs(self.Children) do
		child:OnRemove()
		self.Children[i] = nil
	end
	self:ForceDraw()
end
]],
["Window"]=[[
Inherit = 'View'

ToolBarColour = colours.lightGrey
ToolBarTextColour = colours.black
ShadowColour = colours.grey
Title = ''
Flashing = false
CanClose = true
OnCloseButton = nil

OnLoad = function(self)
	--self:GetObject('View') = self.Bedrock:ObjectFromFile({Type = 'View',Width = 10, Height = 5, BackgroundColour = colours.red}, self)
end

LoadView = function(self)
	local view = self:GetObject('View')
	if view.ToolBarColour then
		window.ToolBarColour = view.ToolBarColour
	end
	if view.ToolBarTextColour then
		window.ToolBarTextColour = view.ToolBarTextColour
	end
	view.X = 1
	view.Y = 2

	view:ForceDraw()
	self:OnUpdate('View')
	if self.OnViewLoad then
		self.OnViewLoad(view)
	end
	self.Bedrock:SetActiveObject(view)
end

SetView = function(self, view)
	self:RemoveObject('View')
	table.insert(self.Children, view)
	view.Parent = self
	self:LoadView()
end

Flash = function(self)
	self.Flashing = true
	self:ForceDraw()
	self.Bedrock:StartTimer(function()self.Flashing = false end, 0.4)
end

OnDraw = function(self, x, y)
	local toolBarColour = (self.Flashing and colours.white or self.ToolBarColour)
	local toolBarTextColour = (self.Flashing and colours.black or self.ToolBarTextColour)
	if toolBarColour then
		Drawing.DrawBlankArea(x, y, self.Width, 1, toolBarColour)
	end
	if toolBarTextColour then
		local title = self.Bedrock.Helpers.TruncateString(self.Title, self.Width - 2)
		Drawing.DrawCharactersCenter(self.X, self.Y, self.Width, 1, title, toolBarTextColour, toolBarColour)
	end
	Drawing.IgnoreConstraint = true
	Drawing.DrawBlankArea(x + 1, y + 1, self.Width, self.Height, self.ShadowColour)
	Drawing.IgnoreConstraint = false
end

Close = function(self)
	self.Bedrock.Window = nil
	self.Bedrock:RemoveObject(self)
	if self.OnClose then
		self:OnClose()
	end
	self = nil
end

OnUpdate = function(self, value)
	if value == 'View' and self:GetObject('View') then
		self.Width = self:GetObject('View').Width
		self.Height = self:GetObject('View').Height + 1
		self.X = math.ceil((Drawing.Screen.Width - self.Width) / 2)
		self.Y = math.ceil((Drawing.Screen.Height - self.Height) / 2)
	elseif value == 'CanClose' then
		self:RemoveObject('CloseButton')
		if self.CanClose then
			local button = self:AddObject({X = 1, Y = 1, Width = 1, Height = 1, Type = 'Button', BackgroundColour = colours.red, TextColour = colours.white, Text = 'x', Name = 'CloseButton'})
			button.OnClick = function(btn)
				if self.OnCloseButton then
					self:OnCloseButton()
				end
				self:Close()
			end
		end
	end
end
]],
}
BasePath=''
ProgramPath=nil
function LoadAPIs(o)
local function n(o,e)
local t=setmetatable({},{__index=getfenv()})
local e,a=loadstring(e)
if not e then
return false,printError(a)
end
setfenv(e,t)
e()
local e={}
for t,a in pairs(t)do
e[t]=a
end
_G[o]=e
return true
end
local t=getfenv()
local function i(e,s)
n(e,s)
if t[e].Inherit then
if not getfenv()[t[e].Inherit]then
if a[t[e].Inherit]then
i(t[e].Inherit,a[t[e].Inherit])
elseif fs.exists(o.ProgramPath..'/Objects/'..t[e].Inherit..'.lua')then
end
end
t[e].__index=getfenv()[t[e].Inherit]
else
t[e].__index=Object
end
setmetatable(t[e],t[e])
end
for e,t in pairs(s)do
n(e,t)
if e=='Helpers'then
o.Helpers=Helpers
end
end
for e,t in pairs(a)do
i(e,t)
end
local e=o.ProgramPath..'/Objects/'
if fs.exists(e)and fs.isDir(e)then
for a,t in ipairs(fs.list(e))do
local a=string.match(t,'(%a+)%.?.-')
local e=fs.open(e..t,'r')
i(a,e.readAll())
e.close()
end
end
end
AllowTerminate=true
View=nil
Menu=nil
ActiveObject=nil
DrawTimer=nil
DrawTimerExpiry=0
IsDrawing=false
DefaultView='main'
EventHandlers={
}
ObjectClickHandlers={
}
ObjectUpdateHandlers={
}
Timers={
}
function Initialise(e)
local t=e.ProgramPath or shell.getRunningProgram()
local a=fs.getName(t)
e.ProgramPath=t:sub(1,#t-#a-1)
e:LoadAPIs()
e.ViewPath=e.ProgramPath..'/Views/'
local a={
'Drawing',
'View'
}
local t=getfenv()
for a,e in ipairs(a)do
if not t[e]then
error('The API: '..e..' is not loaded. Please make sure you load it to use Bedrock.')
end
end
local t={}
for e,a in pairs(e)do
if e~='Initialise'then
t[e]=a
end
end
return setmetatable(t,getmetatable(e))
end
function HandleClick(e,i,o,a,t)
if e.Window then
if not e.View:CheckClick(e.Window,a,t)then
e.Window:Flash()
else
e.View:DoClick(e.Window,i,o,a,t)
end
elseif e.Menu then
if not e.View:DoClick(e.Menu,i,o,a,t)then
e.Menu:Close()
end
elseif e.View then
if e.View:Click(i,o,a,t)~=false then
end
end
end
function HandleKeyChar(e,a,t)
if e:GetActiveObject()then
local e=e:GetActiveObject()
if e.OnKeyChar then
if e:OnKeyChar(a,t)~=false then
end
end
end
end
function ToggleMenu(e,o,i,a,t)
if e.Menu then
e.Menu:Close()
return false
else
e:SetMenu(o,i,a,t)
return true
end
end
function SetMenu(e,i,o,t,a)
t=t or 1
a=a or 1
if e.Menu then
e.Menu:Close()
end
if i then
local n=o:GetPosition()
e.Menu=e:AddObject(i,{Type='Menu',Owner=o,X=n.X+t-1,Y=n.Y+a})
end
end
function ObjectClick(e,t,a)
e.ObjectClickHandlers[t]=a
end
function ClickObject(t,e,a,i,n,o)
if t.ObjectClickHandlers[e.Name]then
return t.ObjectClickHandlers[e.Name](e,a,i,n,o)
end
return false
end
function ObjectUpdate(a,e,t)
a.ObjectUpdateHandlers[e]=t
end
function UpdateObject(t,e,...)
if t.ObjectUpdateHandlers[e.Name]then
t.ObjectUpdateHandlers[e.Name](e,...)
end
end
function GetAbsolutePosition(t,e)
if not e.Parent then
return{X=e.X,Y=e.Y}
else
local a=t:GetAbsolutePosition(e.Parent)
local t=a.X+e.X-1
local a=a.Y+e.Y-1
if not e.Fixed and e.Parent.ChildOffset then
t=t+e.Parent.ChildOffset.X
a=a+e.Parent.ChildOffset.Y
end
return{X=t,Y=a}
end
end
function LoadView(e,o,n)
if e.View and e.OnViewClose then
e.OnViewClose(e.View.Name)
end
if e.View then
e.View:OnRemove()
end
local a=false
local i=fs.open(e.ViewPath..o..'.view','r')
if i then
local t=textutils.unserialize(i.readAll())
i.close()
if t then
e.View=View:InitialiseFile(e,t,o)
e:ReorderObjects()
if OneOS and t.ToolBarColour then
OneOS.ToolBarColour=t.ToolBarColour
end
if OneOS and t.ToolBarTextColour then
OneOS.ToolBarTextColour=t.ToolBarTextColour
end
if not e:GetActiveObject()then
e:SetActiveObject()
end
a=true
end
end
if a and e.OnViewLoad then
e.OnViewLoad(o)
end
if n~=false then
e:Draw()
end
if not a then
error('Failed to load view: '..o..'. It probably isn\'t formatted correctly.')
end
return a
end
function InheritFile(t,e,a)
local t=fs.open(t.ViewPath..a..'.view','r')
if t then
local t=textutils.unserialize(t.readAll())
if t then
if type(t)~='table'then
error('View: "'..a..'.view" is not formatted correctly.')
end
for t,a in pairs(t)do
if not e[t]then
e[t]=a
end
end
return e
end
end
return e
end
function ObjectFromFile(o,t,n)
local i=getfenv()
if i[t.Type]then
if not i[t.Type].Initialise then
error('Malformed Object: '..t.Type)
end
local e={}
if t.InheritView then
t=o:InheritFile(t,t.InheritView)
end
e.AutoWidth=true
for a,t in pairs(t)do
if a=='Width'or a=='X'or a=='Height'or a=='Y'then
local o=n.Width
if a=='Height'or a=='Y'then
o=n.Height
end
local e={t}
if type(t)=='string'and string.find(t,',')then
e={}
for t in string.gmatch(t,'([^,]+)')do
table.insert(e,t)
end
end
t=0
for a,e in ipairs(e)do
if type(e)=='string'and e:sub(#e)=='%'then
t=t+math.ceil(o*(tonumber(e:sub(1,#e-1))/100))
else
t=t+tonumber(e)
end
end
end
if a=='Width'then
e.AutoWidth=false
end
if a~='Children'then
e[a]=t
else
e[a]={}
end
end
e.Parent=n
e.Bedrock=o
if not e.Name then
e.Name=t.Type
end
e=i[t.Type]:Initialise(e)
if t.Children then
for a,t in ipairs(t.Children)do
local t=o:ObjectFromFile(t,e)
if not t.Z then
t.Z=a
end
t.Parent=e
table.insert(e.Children,t)
end
end
if not e.OnClick then
e.OnClick=function(...)return o:ClickObject(...)end
end
if e.OnUpdate then
for t,a in pairs(i[t.Type])do
e:OnUpdate(t)
end
for t,a in pairs(e.__index)do
e:OnUpdate(t)
end
end
if e.Active then
e.Bedrock:SetActiveObject(e)
end
if e.OnLoad then
e:OnLoad()
end
return e
elseif not t.Type then
error('No object type specified. (e.g. Type = "Button")')
else
error('No Object: '..t.Type..'. The API probably isn\'t loaded')
end
end
function ReorderObjects(e)
if e.View and e.View.Children then
table.sort(e.View.Children,function(t,e)
return t.Z<e.Z
end)
end
end
function AddObject(a,t,e)
return a.View:AddObject(t,e)
end
function GetObject(e,t)
return e.View:GetObject(t)
end
function GetObjects(t,e)
return t.View:GetObjects(e)
end
function RemoveObject(t,e)
return t.View:RemoveObject(e)
end
function RemoveObjects(t,e)
return t.View:RemoveObjects(e)
end
function ForceDraw(e)
if not e.DrawTimer or e.DrawTimerExpiry<=os.clock()then
e.DrawTimer=e:StartTimer(function()
e.DrawTimer=nil
e:Draw()
end,.05)
e.DrawTimerExpiry=os.clock()+.1
end
end
function DisplayWindow(t,e,o,a)
if a==nil then
a=true
end
if type(e)=='string'then
local t=fs.open(t.ViewPath..e..'.view','r')
if t then
e=textutils.unserialize(t.readAll())
t.close()
end
end
t.Window=t:AddObject({Type='Window',Z=999,Title=o,CanClose=a})
e.Type='View'
e.Name='View'
e.BackgroundColour=e.BackgroundColour or colours.white
t.Window:SetView(t:ObjectFromFile(e,t.Window))
end
function DisplayAlertWindow(s,r,n,e,t)
local h=function(e)
s.Window:Close()
if t then
t(e.Text)
end
end
local o={}
local t=-1
if e then
for a,e in ipairs(e)do
t=t+3+#e
table.insert(o,{
["Y"]="100%,-1",
["X"]="100%,-"..t,
["Name"]=e.."Button",
["Type"]="Button",
["Text"]=e,
OnClick=h
})
end
end
local t=t+2
if t<28 then
t=28
end
local a=true
if e and#e~=0 then
a=false
end
local i=#Helpers.WrapText(n,t-2)
table.insert(o,{
["Y"]=2,
["X"]=2,
["Width"]="100%,-2",
["Height"]=i,
["Name"]="Label",
["Type"]="Label",
["Text"]=n
})
local e={
Children=o,
Width=t,
Height=3+i+(a and 0 or 1),
OnKeyChar=function(t,t)
h({Text=e[1]})
end
}
s:DisplayWindow(e,r,a)
end
function DisplayTextBoxWindow(e,h,o,t,n,s)
n=n or''
local a=function(a)
e.Window:Close()
if t then
t(a.Text)
end
end
local i={
{
["Y"]="100%,-1",
["X"]="100%,-4",
["Name"]="OkButton",
["Type"]="Button",
["Text"]="Ok",
OnClick=function()
local a=e.Window:GetObject('TextBox').Text
e.Window:Close()
t(true,a)
end
},
{
["Y"]="100%,-1",
["X"]="100%,-13",
["Name"]="CancelButton",
["Type"]="Button",
["Text"]="Cancel",
OnClick=function()
e.Window:Close()
t(false)
end
}
}
local a=-1
if o and#o~=0 then
a=#Helpers.WrapText(o,26)
table.insert(i,{
["Y"]=2,
["X"]=2,
["Width"]="100%,-2",
["Height"]=a,
["Name"]="Label",
["Type"]="Label",
["Text"]=o
})
end
table.insert(i,
{
["Y"]=3+a,
["X"]=2,
["Width"]="100%,-2",
["Name"]="TextBox",
["Type"]="TextBox",
["Text"]=n,
["CursorPos"]=(s and 0 or nil)
})
local a={
Children=i,
Width=28,
Height=5+a+(canClose and 0 or 1),
}
e:DisplayWindow(a,h)
e.Window:GetObject('TextBox').OnUpdate=function(o,a)
if a==keys.enter then
e.Window:Close()
t(true,o.Text)
end
end
e:SetActiveObject(e.Window:GetObject('TextBox'))
e.Window.OnCloseButton=function()t(false)end
end
function RegisterEvent(e,t,a)
if not e.EventHandlers[t]then
e.EventHandlers[t]={}
end
table.insert(e.EventHandlers[t],a)
end
function StartRepeatingTimer(o,a,t)
local e=t
if type(e)=='function'then
e=e()
end
if not e or e<=0 then
return
end
local e=os.startTimer(e)
o.Timers[e]={a,true,t}
return e
end
function StartTimer(t,a,e)
local e=os.startTimer(e)
t.Timers[e]={a,false}
return e
end
function StopTimer(e,t)
if e.Timers[t]then
e.Timers[t]=nil
end
end
function HandleTimer(e,o,a)
if e.Timers[a]then
local t=e.Timers[a]
e.Timers[a]=nil
t[1]()
if t[2]then
e:StartRepeatingTimer(t[1],t[3])
end
elseif e.OnTimer then
e.OnTimer(e,o,a)
end
end
function SetActiveObject(e,t)
if t then
if t~=e.ActiveObject then
e.ActiveObject=t
t:ForceDraw()
end
elseif e.ActiveObject~=nil then
e.ActiveObject=nil
e.CursorPos=nil
e.View:ForceDraw()
end
end
function GetActiveObject(e)
return e.ActiveObject
end
OnTimer=nil
OnClick=nil
OnKeyChar=nil
OnDrag=nil
OnScroll=nil
OnViewLoad=nil
OnViewClose=nil
OnDraw=nil
local o={
OnClick={'mouse_click'},
OnKeyChar={'key','char'},
OnDrag={'mouse_drag'},
OnScroll={'mouse_scroll'},
HandleClick={'mouse_click','mouse_drag','mouse_scroll'},
HandleKeyChar={'key','char'},
HandleTimer={'timer'}
}
local t=0
local e=0
function Draw(e)
e.IsDrawing=true
if e.OnDraw then
e:OnDraw()
end
if e.View and e.View:NeedsDraw()then
e.View:Draw()
Drawing.DrawBuffer()
if isDebug then
t=t+1
end
elseif not e.View then
print('No loaded view. You need to do program:LoadView first.')
end
if e:GetActiveObject()and e.CursorPos and type(e.CursorPos[1])=='number'and type(e.CursorPos[2])=='number'then
term.setCursorPos(e.CursorPos[1],e.CursorPos[2])
term.setTextColour(e.CursorColour)
term.setCursorBlink(true)
else
term.setCursorBlink(false)
end
e.IsDrawing=false
end
function EventHandler(e)
local t={os.pullEventRaw()}
if e.EventHandlers[t[1]]then
for o,a in ipairs(e.EventHandlers[t[1]])do
a(e,unpack(t))
end
end
end
function Run(e,a)
for t,a in pairs(o)do
if e[t]then
for o,a in ipairs(a)do
e:RegisterEvent(a,e[t])
end
end
end
if e.AllowTerminate then
e:RegisterEvent('terminate',function()error('Terminated',0)end)
end
print(e.ViewPath..e.DefaultView..'.lua')
if e.DefaultView and e.DefaultView~=''and fs.exists(e.ViewPath..e.DefaultView..'.view')then
e:LoadView(e.DefaultView)
end
if a then
a()
end
e:Draw()
while true do
e:EventHandler()
end
end